using MarketAnalyzer.Foundation;

namespace MarketAnalyzer.Domain.Entities;

/// <summary>
/// Represents a trading recommendation generated by the analysis engine.
/// Core entity for the MarketAnalyzer system's recommendation output.
/// ALL financial values MUST use decimal type for precision compliance.
/// </summary>
public class TradingRecommendation
{
    /// <summary>
    /// Gets the unique identifier for this recommendation.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the stock symbol this recommendation applies to.
    /// </summary>
    public string Symbol { get; private set; }

    /// <summary>
    /// Gets the type of recommendation (Buy, Sell, Hold).
    /// </summary>
    public RecommendationType Type { get; private set; }

    /// <summary>
    /// Gets the target price for this recommendation. MANDATORY: decimal for financial precision.
    /// </summary>
    public decimal TargetPrice { get; private set; }

    /// <summary>
    /// Gets the stop loss price. MANDATORY: decimal for financial precision.
    /// </summary>
    public decimal StopLoss { get; private set; }

    /// <summary>
    /// Gets the confidence level (0.0 to 1.0 scale). MANDATORY: decimal for precision.
    /// </summary>
    public decimal Confidence { get; private set; }

    /// <summary>
    /// Gets the rationale/reasoning for this recommendation.
    /// </summary>
    public string Rationale { get; private set; }

    /// <summary>
    /// Gets the timestamp when this recommendation was generated.
    /// </summary>
    public DateTime GeneratedAt { get; private set; }

    /// <summary>
    /// Gets how long this recommendation is valid for.
    /// </summary>
    public TimeSpan ValidFor { get; private set; }

    /// <summary>
    /// Gets the expiration time for this recommendation.
    /// </summary>
    public DateTime ExpiresAt => GeneratedAt + ValidFor;

    /// <summary>
    /// Gets the signals that contributed to this recommendation.
    /// </summary>
    public IReadOnlyList<Signal> Signals { get; private set; }

    /// <summary>
    /// Gets the current market price when the recommendation was made. MANDATORY: decimal.
    /// </summary>
    public decimal CurrentPrice { get; private set; }

    /// <summary>
    /// Gets the risk level assessment for this recommendation.
    /// </summary>
    public RiskLevel RiskLevel { get; private set; }

    /// <summary>
    /// Gets the position size recommendation as a percentage of portfolio. MANDATORY: decimal.
    /// </summary>
    public decimal? PositionSize { get; private set; }

    /// <summary>
    /// Gets additional metadata and context for this recommendation.
    /// </summary>
    public Dictionary<string, object> Metadata { get; private set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradingRecommendation"/> class.
    /// </summary>
    /// <param name="symbol">The stock symbol</param>
    /// <param name="type">The recommendation type</param>
    /// <param name="targetPrice">The target price (MUST be decimal)</param>
    /// <param name="stopLoss">The stop loss price (MUST be decimal)</param>
    /// <param name="confidence">The confidence level (0.0 to 1.0, MUST be decimal)</param>
    /// <param name="rationale">The rationale for the recommendation</param>
    /// <param name="validFor">How long the recommendation is valid</param>
    /// <param name="signals">The contributing signals</param>
    /// <param name="currentPrice">The current market price (MUST be decimal)</param>
    /// <param name="riskLevel">The risk level assessment</param>
    /// <param name="positionSize">Optional position size recommendation (MUST be decimal if provided)</param>
    public TradingRecommendation(
        string symbol,
        RecommendationType type,
        decimal targetPrice,
        decimal stopLoss,
        decimal confidence,
        string rationale,
        TimeSpan validFor,
        IList<Signal> signals,
        decimal currentPrice,
        RiskLevel riskLevel,
        decimal? positionSize = null)
    {
        Id = Guid.NewGuid();
        Symbol = ValidateSymbol(symbol);
        Type = type;
        TargetPrice = ValidatePrice(targetPrice, nameof(targetPrice));
        StopLoss = ValidatePrice(stopLoss, nameof(stopLoss));
        Confidence = ValidateConfidence(confidence);
        Rationale = ValidateRationale(rationale);
        ValidFor = ValidateValidFor(validFor);
        Signals = signals?.ToList().AsReadOnly() ?? new List<Signal>().AsReadOnly();
        CurrentPrice = ValidatePrice(currentPrice, nameof(currentPrice));
        RiskLevel = riskLevel;
        PositionSize = positionSize.HasValue ? ValidatePositionSize(positionSize.Value) : null;
        GeneratedAt = DateTime.UtcNow;
        Metadata = new Dictionary<string, object>();

        ValidateRecommendationLogic();
    }

    /// <summary>
    /// Calculates the potential return if the target price is reached. MANDATORY: decimal result.
    /// </summary>
    /// <returns>The potential return as a percentage (e.g., 0.10 for 10%)</returns>
    public TradingResult<decimal> GetPotentialReturn()
    {
        try
        {
            if (CurrentPrice == 0)
            {
                return TradingResult<decimal>.Failure("DIVISION_BY_ZERO", "Cannot calculate return when current price is zero");
            }

            decimal returnPercentage = Type switch
            {
                RecommendationType.Buy => (TargetPrice - CurrentPrice) / CurrentPrice,
                RecommendationType.Sell => (CurrentPrice - TargetPrice) / CurrentPrice,
                RecommendationType.Hold => 0m,
                _ => 0m
            };

            return TradingResult<decimal>.Success(returnPercentage);
        }
        catch (Exception ex)
        {
            return TradingResult<decimal>.Failure("RETURN_CALCULATION_ERROR", $"Failed to calculate potential return: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Calculates the risk-to-reward ratio. MANDATORY: decimal result.
    /// </summary>
    /// <returns>The risk-to-reward ratio</returns>
    public TradingResult<decimal> GetRiskRewardRatio()
    {
        try
        {
            decimal risk;
            decimal reward;

            switch (Type)
            {
                case RecommendationType.Buy:
                    risk = Math.Abs(CurrentPrice - StopLoss);
                    reward = Math.Abs(TargetPrice - CurrentPrice);
                    break;
                case RecommendationType.Sell:
                    risk = Math.Abs(StopLoss - CurrentPrice);
                    reward = Math.Abs(CurrentPrice - TargetPrice);
                    break;
                case RecommendationType.Hold:
                    return TradingResult<decimal>.Success(0m);
                default:
                    return TradingResult<decimal>.Failure("INVALID_RECOMMENDATION_TYPE", "Unknown recommendation type");
            }

            if (risk == 0)
            {
                return TradingResult<decimal>.Failure("ZERO_RISK", "Cannot calculate risk-reward ratio when risk is zero");
            }

            var ratio = reward / risk;
            return TradingResult<decimal>.Success(ratio);
        }
        catch (Exception ex)
        {
            return TradingResult<decimal>.Failure("RATIO_CALCULATION_ERROR", $"Failed to calculate risk-reward ratio: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Determines if this recommendation is still valid (not expired).
    /// </summary>
    /// <returns>True if the recommendation is still valid</returns>
    public bool IsValid()
    {
        return DateTime.UtcNow < ExpiresAt;
    }

    /// <summary>
    /// Gets the remaining time until this recommendation expires.
    /// </summary>
    /// <returns>The remaining time, or TimeSpan.Zero if expired</returns>
    public TimeSpan GetRemainingTime()
    {
        var remaining = ExpiresAt - DateTime.UtcNow;
        return remaining > TimeSpan.Zero ? remaining : TimeSpan.Zero;
    }

    /// <summary>
    /// Adds metadata to the recommendation.
    /// </summary>
    /// <param name="key">The metadata key</param>
    /// <param name="value">The metadata value</param>
    /// <returns>A result indicating success or failure</returns>
    public TradingResult<bool> AddMetadata(string key, object value)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(key))
            {
                return TradingResult<bool>.Failure("INVALID_KEY", "Metadata key cannot be null or empty");
            }

            Metadata[key] = value;
            return TradingResult<bool>.Success(true);
        }
        catch (Exception ex)
        {
            return TradingResult<bool>.Failure("METADATA_ADD_FAILED", $"Failed to add metadata: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Gets the signals of a specific type.
    /// </summary>
    /// <param name="source">The signal source to filter by</param>
    /// <returns>Signals from the specified source</returns>
    public IEnumerable<Signal> GetSignalsBySource(string source)
    {
        return Signals.Where(s => s.Source.Equals(source, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Gets the average signal strength for all signals.
    /// </summary>
    /// <returns>The average signal strength</returns>
    public TradingResult<decimal> GetAverageSignalStrength()
    {
        try
        {
            if (!Signals.Any())
            {
                return TradingResult<decimal>.Success(0m);
            }

            var average = Signals.Average(s => (decimal)s.Strength);
            return TradingResult<decimal>.Success(average);
        }
        catch (Exception ex)
        {
            return TradingResult<decimal>.Failure("SIGNAL_STRENGTH_CALCULATION_ERROR", $"Failed to calculate average signal strength: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Returns a string representation of the recommendation.
    /// </summary>
    /// <returns>A string representation</returns>
    public override string ToString()
    {
        var validityStatus = IsValid() ? "VALID" : "EXPIRED";
        return $"{Type} {Symbol} @ {TargetPrice:C} (Confidence: {Confidence:P2}, {validityStatus})";
    }

    #region Validation Methods

    private static string ValidateSymbol(string symbol)
    {
        if (string.IsNullOrWhiteSpace(symbol))
            throw new ArgumentException("Symbol cannot be null or empty", nameof(symbol));

        return symbol.ToUpperInvariant().Trim();
    }

    private static decimal ValidatePrice(decimal price, string parameterName)
    {
        if (price <= 0)
            throw new ArgumentException($"Price must be positive: {price}", parameterName);

        return price;
    }

    private static decimal ValidateConfidence(decimal confidence)
    {
        if (confidence < 0m || confidence > 1m)
            throw new ArgumentException($"Confidence must be between 0.0 and 1.0: {confidence}", nameof(confidence));

        return confidence;
    }

    private static string ValidateRationale(string rationale)
    {
        if (string.IsNullOrWhiteSpace(rationale))
            throw new ArgumentException("Rationale cannot be null or empty", nameof(rationale));

        return rationale.Trim();
    }

    private static TimeSpan ValidateValidFor(TimeSpan validFor)
    {
        if (validFor <= TimeSpan.Zero)
            throw new ArgumentException("ValidFor must be positive", nameof(validFor));

        if (validFor > TimeSpan.FromDays(30))
            throw new ArgumentException("ValidFor cannot exceed 30 days", nameof(validFor));

        return validFor;
    }

    private static decimal ValidatePositionSize(decimal positionSize)
    {
        if (positionSize <= 0m || positionSize > 1m)
            throw new ArgumentException($"Position size must be between 0.0 and 1.0: {positionSize}", nameof(positionSize));

        return positionSize;
    }

    private void ValidateRecommendationLogic()
    {
        switch (Type)
        {
            case RecommendationType.Buy:
                if (TargetPrice <= CurrentPrice)
                    throw new ArgumentException("For Buy recommendations, target price must be higher than current price");
                if (StopLoss >= CurrentPrice)
                    throw new ArgumentException("For Buy recommendations, stop loss must be lower than current price");
                break;

            case RecommendationType.Sell:
                if (TargetPrice >= CurrentPrice)
                    throw new ArgumentException("For Sell recommendations, target price must be lower than current price");
                if (StopLoss <= CurrentPrice)
                    throw new ArgumentException("For Sell recommendations, stop loss must be higher than current price");
                break;

            case RecommendationType.Hold:
                // Hold recommendations can have flexible target and stop loss prices
                break;

            default:
                throw new ArgumentException($"Unknown recommendation type: {Type}");
        }
    }

    #endregion
}

/// <summary>
/// Represents the type of trading recommendation.
/// </summary>
public enum RecommendationType
{
    /// <summary>
    /// Hold the current position or stay out of the market
    /// </summary>
    Hold = 0,

    /// <summary>
    /// Buy the stock (go long)
    /// </summary>
    Buy = 1,

    /// <summary>
    /// Sell the stock (close long position or go short)
    /// </summary>
    Sell = 2,

    /// <summary>
    /// Strong buy recommendation
    /// </summary>
    StrongBuy = 3,

    /// <summary>
    /// Strong sell recommendation
    /// </summary>
    StrongSell = 4
}

/// <summary>
/// Represents the risk level of a trading recommendation.
/// </summary>
public enum RiskLevel
{
    /// <summary>
    /// Low risk
    /// </summary>
    Low = 1,

    /// <summary>
    /// Medium risk
    /// </summary>
    Medium = 2,

    /// <summary>
    /// High risk
    /// </summary>
    High = 3,

    /// <summary>
    /// Very high risk
    /// </summary>
    VeryHigh = 4
}