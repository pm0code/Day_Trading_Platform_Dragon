using MarketAnalyzer.Foundation;

namespace MarketAnalyzer.Domain.Entities;

/// <summary>
/// Represents a trading signal that contributes to recommendation generation.
/// Signals are generated by technical analysis, AI models, or fundamental analysis.
/// </summary>
public class Signal
{
    /// <summary>
    /// Gets the unique identifier for this signal.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the name of the signal (e.g., "RSI_Oversold", "MACD_BullishCrossover").
    /// </summary>
    public string Name { get; private set; }

    /// <summary>
    /// Gets the strength of the signal.
    /// </summary>
    public SignalStrength Strength { get; private set; }

    /// <summary>
    /// Gets the source that generated this signal (e.g., "Technical", "AI", "Fundamental").
    /// </summary>
    public string Source { get; private set; }

    /// <summary>
    /// Gets the numerical value of the signal. MANDATORY: decimal for precision.
    /// </summary>
    public decimal Value { get; private set; }

    /// <summary>
    /// Gets the timestamp when this signal was generated.
    /// </summary>
    public DateTime GeneratedAt { get; private set; }

    /// <summary>
    /// Gets the stock symbol this signal applies to.
    /// </summary>
    public string Symbol { get; private set; }

    /// <summary>
    /// Gets the timeframe this signal applies to (e.g., "1m", "5m", "1h", "1d").
    /// </summary>
    public string Timeframe { get; private set; }

    /// <summary>
    /// Gets additional parameters and context for this signal.
    /// </summary>
    public Dictionary<string, object> Parameters { get; private set; }

    /// <summary>
    /// Gets the confidence level of this signal (0.0 to 1.0). MANDATORY: decimal for precision.
    /// </summary>
    public decimal Confidence { get; private set; }

    /// <summary>
    /// Gets the direction of the signal (bullish, bearish, or neutral).
    /// </summary>
    public SignalDirection Direction { get; private set; }

    /// <summary>
    /// Gets a description of what this signal indicates.
    /// </summary>
    public string Description { get; private set; }

    /// <summary>
    /// Gets a value indicating whether this signal is still active/valid.
    /// </summary>
    public bool IsActive { get; private set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="Signal"/> class.
    /// </summary>
    /// <param name="name">The signal name</param>
    /// <param name="strength">The signal strength</param>
    /// <param name="source">The signal source</param>
    /// <param name="value">The signal value (MUST be decimal)</param>
    /// <param name="symbol">The stock symbol</param>
    /// <param name="timeframe">The timeframe</param>
    /// <param name="confidence">The confidence level (0.0 to 1.0, MUST be decimal)</param>
    /// <param name="direction">The signal direction</param>
    /// <param name="description">The signal description</param>
    /// <param name="isActive">Whether the signal is active</param>
    public Signal(
        string name,
        SignalStrength strength,
        string source,
        decimal value,
        string symbol,
        string timeframe,
        decimal confidence,
        SignalDirection direction,
        string description,
        bool isActive = true)
    {
        Id = Guid.NewGuid();
        Name = ValidateName(name);
        Strength = strength;
        Source = ValidateSource(source);
        Value = value;
        Symbol = ValidateSymbol(symbol);
        Timeframe = ValidateTimeframe(timeframe);
        Confidence = ValidateConfidence(confidence);
        Direction = direction;
        Description = ValidateDescription(description);
        IsActive = isActive;
        GeneratedAt = DateTime.UtcNow;
        Parameters = new Dictionary<string, object>();
    }

    /// <summary>
    /// Adds a parameter to the signal.
    /// </summary>
    /// <param name="key">The parameter key</param>
    /// <param name="value">The parameter value</param>
    /// <returns>A result indicating success or failure</returns>
    public TradingResult<bool> AddParameter(string key, object value)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(key))
            {
                return TradingResult<bool>.Failure("INVALID_KEY", "Parameter key cannot be null or empty");
            }

            Parameters[key] = value;
            return TradingResult<bool>.Success(true);
        }
        catch (Exception ex)
        {
            return TradingResult<bool>.Failure("PARAMETER_ADD_FAILED", $"Failed to add parameter: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Gets a parameter value by key.
    /// </summary>
    /// <typeparam name="T">The type of the parameter value</typeparam>
    /// <param name="key">The parameter key</param>
    /// <returns>The parameter value or default if not found</returns>
    public TradingResult<T?> GetParameter<T>(string key)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(key))
            {
                return TradingResult<T?>.Failure("INVALID_KEY", "Parameter key cannot be null or empty");
            }

            if (!Parameters.TryGetValue(key, out var value))
            {
                return TradingResult<T?>.Success(default(T));
            }

            if (value is T typedValue)
            {
                return TradingResult<T?>.Success(typedValue);
            }

            // Try to convert the value
            var convertedValue = (T)Convert.ChangeType(value, typeof(T));
            return TradingResult<T?>.Success(convertedValue);
        }
        catch (Exception ex)
        {
            return TradingResult<T?>.Failure("PARAMETER_GET_FAILED", $"Failed to get parameter: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Deactivates the signal.
    /// </summary>
    /// <returns>A result indicating success or failure</returns>
    public TradingResult<bool> Deactivate()
    {
        try
        {
            IsActive = false;
            return TradingResult<bool>.Success(true);
        }
        catch (Exception ex)
        {
            return TradingResult<bool>.Failure("DEACTIVATION_FAILED", $"Failed to deactivate signal: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Calculates the weighted strength based on confidence. MANDATORY: decimal result.
    /// </summary>
    /// <returns>The weighted strength value</returns>
    public TradingResult<decimal> GetWeightedStrength()
    {
        try
        {
            var numericStrength = (decimal)Strength;
            var weightedStrength = numericStrength * Confidence;
            return TradingResult<decimal>.Success(weightedStrength);
        }
        catch (Exception ex)
        {
            return TradingResult<decimal>.Failure("WEIGHTED_STRENGTH_CALCULATION_ERROR", $"Failed to calculate weighted strength: {ex.Message}", ex);
        }
    }

    /// <summary>
    /// Determines if this signal is compatible with another signal for aggregation.
    /// </summary>
    /// <param name="other">The other signal</param>
    /// <returns>True if the signals are compatible</returns>
    public bool IsCompatibleWith(Signal other)
    {
        if (other == null)
            return false;

        return Symbol.Equals(other.Symbol, StringComparison.OrdinalIgnoreCase) &&
               Timeframe.Equals(other.Timeframe, StringComparison.OrdinalIgnoreCase) &&
               IsActive && other.IsActive;
    }

    /// <summary>
    /// Gets the age of this signal.
    /// </summary>
    /// <returns>The age of the signal</returns>
    public TimeSpan GetAge()
    {
        return DateTime.UtcNow - GeneratedAt;
    }

    /// <summary>
    /// Determines if this signal is stale based on the specified age threshold.
    /// </summary>
    /// <param name="maxAge">The maximum acceptable age</param>
    /// <returns>True if the signal is stale</returns>
    public bool IsStale(TimeSpan maxAge)
    {
        return GetAge() > maxAge;
    }

    /// <summary>
    /// Creates a cache key for this signal.
    /// </summary>
    /// <returns>A cache key string</returns>
    public string GetCacheKey()
    {
        return $"signal:{Symbol}:{Source}:{Name}:{Timeframe}:{GeneratedAt:yyyyMMddHHmmss}";
    }

    /// <summary>
    /// Returns a string representation of the signal.
    /// </summary>
    /// <returns>A string representation</returns>
    public override string ToString()
    {
        var directionSymbol = Direction switch
        {
            SignalDirection.Bullish => "↑",
            SignalDirection.Bearish => "↓",
            SignalDirection.Neutral => "→",
            _ => "?"
        };

        return $"{Name} ({Source}): {Strength} {directionSymbol} [{Confidence:P1}] - {Symbol} {Timeframe}";
    }

    #region Validation Methods

    private static string ValidateName(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Signal name cannot be null or empty", nameof(name));

        return name.Trim();
    }

    private static string ValidateSource(string source)
    {
        if (string.IsNullOrWhiteSpace(source))
            throw new ArgumentException("Signal source cannot be null or empty", nameof(source));

        return source.Trim();
    }

    private static string ValidateSymbol(string symbol)
    {
        if (string.IsNullOrWhiteSpace(symbol))
            throw new ArgumentException("Symbol cannot be null or empty", nameof(symbol));

        return symbol.ToUpperInvariant().Trim();
    }

    private static string ValidateTimeframe(string timeframe)
    {
        if (string.IsNullOrWhiteSpace(timeframe))
            throw new ArgumentException("Timeframe cannot be null or empty", nameof(timeframe));

        return timeframe.Trim();
    }

    private static decimal ValidateConfidence(decimal confidence)
    {
        if (confidence < 0m || confidence > 1m)
            throw new ArgumentException($"Confidence must be between 0.0 and 1.0: {confidence}", nameof(confidence));

        return confidence;
    }

    private static string ValidateDescription(string description)
    {
        if (string.IsNullOrWhiteSpace(description))
            throw new ArgumentException("Description cannot be null or empty", nameof(description));

        return description.Trim();
    }

    #endregion
}

/// <summary>
/// Represents the strength of a trading signal.
/// </summary>
public enum SignalStrength
{
    /// <summary>
    /// Very weak signal (1)
    /// </summary>
    VeryWeak = 1,

    /// <summary>
    /// Weak signal (2)
    /// </summary>
    Weak = 2,

    /// <summary>
    /// Moderate signal (3)
    /// </summary>
    Moderate = 3,

    /// <summary>
    /// Strong signal (4)
    /// </summary>
    Strong = 4,

    /// <summary>
    /// Very strong signal (5)
    /// </summary>
    VeryStrong = 5
}

/// <summary>
/// Represents the direction of a trading signal.
/// </summary>
public enum SignalDirection
{
    /// <summary>
    /// Neutral signal (no clear direction)
    /// </summary>
    Neutral = 0,

    /// <summary>
    /// Bullish signal (price expected to rise)
    /// </summary>
    Bullish = 1,

    /// <summary>
    /// Bearish signal (price expected to fall)
    /// </summary>
    Bearish = -1
}