using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using TradingPlatform.Core.Models;

namespace TradingPlatform.Backtesting.Interfaces
{
    /// <summary>
    /// Base interface for all backtesting strategies
    /// </summary>
    public interface IBacktestStrategy
    {
        /// <summary>
        /// Strategy name for identification
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Strategy version for tracking changes
        /// </summary>
        string Version { get; }

        /// <summary>
        /// Initialize strategy with context
        /// </summary>
        Task InitializeAsync(IStrategyContext context);

        /// <summary>
        /// Process new market data and generate signals
        /// </summary>
        Task<IEnumerable<Signal>> OnMarketDataAsync(MarketDataUpdate data);

        /// <summary>
        /// Handle order fill notifications
        /// </summary>
        Task OnOrderFilledAsync(OrderFillEvent fillEvent);

        /// <summary>
        /// Handle order rejection notifications
        /// </summary>
        Task OnOrderRejectedAsync(OrderRejectionEvent rejectionEvent);

        /// <summary>
        /// End of day processing
        /// </summary>
        Task OnDayEndAsync(DateTime date, DayEndContext context);

        /// <summary>
        /// Clean up resources
        /// </summary>
        Task DisposeAsync();

        /// <summary>
        /// Get strategy parameters for optimization
        /// </summary>
        IEnumerable<StrategyParameter> GetParameters();

        /// <summary>
        /// Set strategy parameters
        /// </summary>
        void SetParameters(IDictionary<string, object> parameters);

        /// <summary>
        /// Validate strategy configuration
        /// </summary>
        bool Validate(out IEnumerable<string> errors);
    }

    /// <summary>
    /// Context provided to strategies during backtesting
    /// </summary>
    public interface IStrategyContext
    {
        /// <summary>
        /// Current simulation time
        /// </summary>
        DateTime CurrentTime { get; }

        /// <summary>
        /// Portfolio state
        /// </summary>
        IPortfolioState Portfolio { get; }

        /// <summary>
        /// Market data provider
        /// </summary>
        IMarketDataProvider MarketData { get; }

        /// <summary>
        /// Order management
        /// </summary>
        IOrderManager OrderManager { get; }

        /// <summary>
        /// Risk manager
        /// </summary>
        IRiskManager RiskManager { get; }

        /// <summary>
        /// Technical indicators
        /// </summary>
        IIndicatorFactory Indicators { get; }

        /// <summary>
        /// Strategy-specific state storage
        /// </summary>
        IStrategyState State { get; }

        /// <summary>
        /// Logger for strategy
        /// </summary>
        IStrategyLogger Logger { get; }
    }

    /// <summary>
    /// Trading signal generated by strategy
    /// </summary>
    public class Signal
    {
        public string Symbol { get; set; }
        public SignalType Type { get; set; }
        public SignalAction Action { get; set; }
        public decimal Quantity { get; set; }
        public decimal? Price { get; set; }
        public OrderType OrderType { get; set; }
        public TimeInForce TimeInForce { get; set; }
        public Dictionary<string, object> Metadata { get; set; }
        public DateTime Timestamp { get; set; }
        public string Reason { get; set; }
    }

    public enum SignalType
    {
        Entry,
        Exit,
        Increase,
        Decrease,
        StopLoss,
        TakeProfit
    }

    public enum SignalAction
    {
        Buy,
        Sell,
        Short,
        Cover
    }
}